# Ketik 5 baris perintah untuk meng-import beberapa modul yang dibutuhkan
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'Display.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import sys
import cv2, imutils
from PyQt5 import QtWidgets, QtCore
from PyQt5.QtWidgets import QDialog, QApplication, QFileDialog
from PyQt5.uic import loadUi
from PyQt5 import QtGui
from PyQt5.QtGui import QImage, QImage, QPixmap
import numpy as np
#from matplotlib import pyplot as plt


# Pendefinisian Class
class MainWindow(QDialog):
    def __init__(self):
        super(MainWindow, self).__init__()
        # Memanggil file Design GUI yang sudah dibuat tergantung directory karena belum di convert ui ke py
        loadUi(r'C:\Users\Fahmi\OneDrive\Documents\Programing\Belajar Python\Programing\Robotik\Fahri Desrizal_F14190108\Display.ui', self)
        # Mendefinisikan Perilaku obyek Push Button yang bernama "buka_gambar, binerIMage, konversiGray"         
        self.buka.clicked.connect(self.buka_gambar)
        self.save.clicked.connect(self.savePhoto)
        self.tmp = None
        self.fname = None
        self.biner.clicked.connect(self.binerImage)
        self.abu.clicked.connect(self.konversiGray)
        self.hist.clicked.connect(self.histogram)
        self.kont.clicked.connect(self.kontur)
        self.tutup.clicked.connect(self.selesai)
 
    # Membuat/Mendefinisikan fungsi yang bernama 'buka_gambar' 
    def buka_gambar(self):
        self.namaf_name=QFileDialog.getOpenFileName(self,'hitam', '')[0]
        namaf=cv2.imread(self.namaf_name, 1)
        self.namaf_shape=namaf.shape
        #imwrite supaya gambar 'namaf' bisa didefinisikan dan dipanggil ke fungsi lain
        cv2.imwrite('konversi.png', namaf)
        self.photo.setPixmap(QtGui.QPixmap('konversi.png'))

    # Membuat/Mendefinisikan fungsi yang bernama 'konversiGray' 
    def konversiGray (self):
        global namaf1
        #manggil gambar namaf yg udh didefinisikan sebagai 'konversi.png'
        namaf=cv2.imread('konversi.png')
        #Untuk manggil gambar gray scale, makanya ditambahin 0
        namaf1=cv2.imread('konversi.png', 0)
        #diubah jadi "abu.png" supaya dia manggil gambar yg awal
        cv2.imwrite("abu.png", namaf1)
        self.hasilFoto.setPixmap(QtGui.QPixmap('abu.png'))

    # Membuat/Mendefinisikan fungsi yang bernama 'binerImage' 
    def binerImage (self):
        global mask
        namaf =cv2.imread('konversi.png')
        namaf1 = cv2.imread('konversi.png',0)  
        #Untuk manggil gambar jd binary, make namaf1 soalnya dia udh grayscale, kalo manggil yg namaf jdnya binary tp tetep berwarna
        ret, mask = cv2.threshold(namaf1, 42, 255, cv2.THRESH_BINARY)
        hsv=cv2.cvtColor(namaf, cv2.COLOR_BGR2HSV)
        
        #mengambil nilai HSV
        lower_green=np.array([0,0,45])
        upper_green=np.array([110,250,255])
        mask=cv2.inRange(hsv, lower_green, upper_green)
        mask2=cv2.medianBlur(mask, 5)
        res=cv2.bitwise_and(namaf,namaf, mask=mask)
        
        #menghitung nilai RGB
        count=cv2.countNonZero(mask)
        
        citra=res
        avg_color_per_row=np.average(citra, axis=0)
        avg_color=np.average(avg_color_per_row, axis=0)
        sum_color=np.sum(citra, axis=0)
        sum_color2=np.sum(sum_color, axis=0)
        B = ((sum_color2 / count)[0])
        G = ((sum_color2 / count)[1])
        R = ((sum_color2 / count)[2])

        #menghitung hsi
        R2 = R / 255
        G2 = G / 255
        B2 = B / 255

        Cmax = max(R2, G2, B2)
        Cmin = min(R2, G2, B2)
        delta = Cmax - Cmin

        #menghitung hue
        if (delta == 0):
            H = 0
        elif (Cmax == R2):
            H = (60 * (((G2  - B2) / delta) % 6))
        elif (Cmax == G2):
             H = (60 * (((B2  - R2) / delta) + 2))
        elif (Cmax == B2):
            H = (60 * (((R2  - G2) / delta) + 4))
 
        #menghitung saturation
        if (Cmax == 0):
            S = 0
        else:
            S = delta / Cmax
            
        I = ((B+G+R)/3)

        HH=(f'{H:.3f}')
        SS=(f'{S:.4f}')
        II=(f'{I:.3f}')

        h=str(HH)
        s=str(SS)
        i=str(II)

        
        #format 0 angka desimal
        BB=(f'{B:.0f}')
        GG=(f'{G:.0f}')
        RR=(f'{R:.0f}')
        
        b=str(BB)
        g=str(GG)
        r=str(RR)
        
        #menghitung jumlah piksel       
        t1=str(count)

        #menampilkan RGB dan Jumlah Pixel
        self.rgbP.setText(t1)
        self.rgbR.setText(r)
        self.rgbG.setText(g)
        self.rgbB.setText(b)
        self.hsiH.setText(h)
        self.hsiS.setText(s)
        self.hsiI.setText(i)

        #diubah jadi "fix.png" supaya dia manggil gambar yg awal + ditambahin mask2 supaya manggil gambar yg udh jadi biner
        cv2.imwrite("fix.png", mask2)
        self.hasilFoto.setPixmap(QtGui.QPixmap('fix.png')) 

    def kontur(self):
        image = cv2.imread ('fix.png' ,1)
        gray = cv2.cvtColor(image, cv2. COLOR_RGB2GRAY)
        contours, hierarchy = cv2.findContours (gray, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

        image2 = image.copy()
        index =-1
        thickness = 4
        color = (255, 0, 255)

        objects = np.zeros ([image.shape[0], image.shape[1], 3], 'uint8')
        for c in contours:
            cv2.drawContours (objects, [c], -1, color, -1)

            area = str(cv2.contourArea(c))
            pr = cv2.arcLength(c, True)
            x,y,t,l= cv2.boundingRect(c)

            tcm=t*0.026458333
            lcm=l*0.026458333
            pr1=pr*0.026458333

            TT=(f'{tcm:.2f}')
            LL=(f'{lcm:.2f}')
            PP=(f'{pr1:.2f}')

            t1=str(TT)
            l1=str(LL)
            p1=str(PP)

            #center
            M= cv2. moments(c)
            try:
                cx = int(M['m10']/M['m00'])
            except ZeroDivisionError:
                cx = 0
            try:
                cy = int(M['m01']/M['m00'])
            except ZeroDivisionError:
                cy = 0

            cv2. circle(objects, (cx, cy), 4, (0,0,255), -1)

            print("Area: {}, Preimter: {}". format(area, p1))

        cv2.imwrite('hasil.png', objects)
        self.hasilFoto.setPixmap(QtGui.QPixmap('hasil.png'))

        self.objP.setText(p1)
        self.objT.setText(t1)
        self.objL.setText(l1)

    def histogram(self):
        hist = cv2.imread('fix.png')
        #plt.hist(hist.ravel(),256, [0,256], color='r')
        #plt.xlabel("Intensitas (bit)")
        #plt.ylabel("Resolusi")
        #plt.tight_layout()
        #plt.show()

    def setPhoto(self, namaf):
        namaf =cv2.imread('konversi.png')
        self.tmp = 'konversi.png'
        frame = cv2.cvtColor('konversi.png', cv2.COLOR_BGR2RGB)
        namaf = QImage(frame,frame.shape[1], frame.shape[0],frame.strides[0],QImage.Format_RGB888)
        self.photo.setPixmap(QtGui.QPixmap.fromImage(namaf))

    def savePhoto (self):
        fname, filter = QFileDialog.getSaveFileName(self, 'Simpan Hasil', 'simpan', "Image Files (*.png)")
        cv2.imwrite(fname, mask)
        
    def selesai (self):
        sys.exit(app.exec_())
        
app=QApplication(sys.argv)
mainwindow=MainWindow()
widget=QtWidgets.QStackedWidget()
widget.addWidget(mainwindow)
widget.setFixedWidth(1920)
widget.setFixedHeight(1080)
widget.show()
sys.exit(app.exec_())